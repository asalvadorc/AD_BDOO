{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5 Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Fitxers"},{"location":"3__bases_de_dades_orientades_a_objectes/","text":"1 - Bases de Dades Orientades a Objectes L'\u00faltima alternativa que veurem per a guardar els objectes de Java ser\u00e0 fer servir directament una Base de Dades Orientada a Objectes . En principi semblaria que es tracta de la millor soluci\u00f3 ja que no hi ha cap tipus de desfasament, i es podran guardar directament els objectes. Encara aix\u00ed, aquesta modalitat de bases de dades presenta certes peculiaritats que cal tenir molt en compte. Actualment trobem al mercat dos tipus de Bases de Dades Orientades a Objecte. Les que compleixen l\u2019est\u00e0ndard proposat per l\u2019 ODMG (Object Database Management Group) a finals de l\u2019any 2000 Les anomenades bases de dades de tipus NoSQL , iniciatives tecnol\u00f2giques posteriors. En realitat el terme NoSQL (Not Only SQL) es refereix a totes aquelles que no segueixen el Model Relacional, i s'inclourien BD Orientades a Objectes, BD XML, i tamb\u00e9 altres tipus com les documentals, les BD clau-valor, i algun altre tipus. L\u2019ODMG es va desfer l\u2019any 2001, despr\u00e9s de culminar l\u2019est\u00e0ndard anomenat ODMG 3.0. Encara que ja ha passat molt de temps, es tracta d\u2019un est\u00e0ndard molt infrautilitzat . Els llenguatges que especifica (ODL i OQL), encara que tenen una pot\u00e8ncia molt gran i permeten una adaptaci\u00f3 real a la sintaxi habitualment utilitzada per la majoria de llenguatges Orientats a Objectes, presenta una enorme influ\u00e8ncia del paradigma relacional . Aquesta \u00e9s segurament la causa de que hi hagen pocs productes actuals que seguisquen aquest model. I \u00e9s una pena, perqu\u00e8 a banda de guardar c\u00f2modament els objectes, el OQL ens permetria buscar la informaci\u00f3 de forma f\u00e0cil i potent. En els \u00faltims anys han aparegut algunes iniciatives noves que proposen un canvi de plantejament en la gesti\u00f3 dels objectes: les Bases de Dades NoSQL . Es tracta d\u2019un plantejament trencador que vol aprofitar-se de l\u2019estructura interna pr\u00f2pia dels objectes per organitzar la persist\u00e8ncia a mode de punters o refer\u00e8ncies internes, de manera que una vegada guardats els objectes, no es perda la potencialitat que suposa aquesta organitzaci\u00f3. \u00c9s una iniciativa molt jove que sembla cridada a ser la seg\u00fcent generaci\u00f3 en els Sistemes Gestors de Bases de Dades perqu\u00e8 d\u00f3na una resposta molt adequada a l\u2019hora de representar escenaris complexos en els quals les bases de dades cl\u00e0ssiques (relacionals) han fracassat. Ens referim a escenaris amb components gr\u00e0fics o documentals, o a situacions amb informaci\u00f3 extremadament complexa que cal analitzar ( business intelligence , per exemple). DB4O ( Database for Objects ) \u00e9s una de les iniciatives amb llic\u00e8ncia GPL m\u00e9s actives, que implementa una base de dades 100% Orientada a Objectes i basada en el concepte NoSQL . Es tracta d\u2019una base de dades lleugera amb una versi\u00f3 integrada en el propi llenguatge Java ( Embedded ). Aix\u00f2 fa que la seua instal\u00b7laci\u00f3 siga nul\u00b7la, ja que nom\u00e9s cal incorporar a la nostra aplicaci\u00f3 les biblioteques que podem trobar a la p\u00e0gina de l\u2019empresa Versant , per disposar d\u2019una base de dades operativa. I pel seu petit volum i extrema efici\u00e8ncia, s\u2019utilitza tamb\u00e9 molt en aplicacions m\u00f2bils i serveis web. Existeix tamb\u00e9 un versi\u00f3 distribu\u00efda per instal\u00b7lar en un servidor, per\u00f2 la versi\u00f3 integrada ser\u00e0 suficient per agafar les nocions b\u00e0siques que ens cal explicar. L\u2019\u00das de DB4O no precisa crear cap model de dades espec\u00edfic per configurar l\u2019estructura que suporte les dades en SGBDOO. De fet, utilitza la informaci\u00f3 interna dels objectes per construir de forma din\u00e0mica aquesta estructura. L\u2019extracci\u00f3 d\u2019aquesta informaci\u00f3 \u00e9s possible gr\u00e0cies a les caracter\u00edstiques reflexives dels llenguatges de programaci\u00f3 als quals d\u00f3na suport (Java i C#). DB4O no guarda els objectes basant-se en els seus valors, sin\u00f3 en les seues refer\u00e8ncies en mem\u00f2ria. Dos objectes ubicats en llocs diferents de la mem\u00f2ria RAM, encara que representen el mateix, si es guarden en DB4O es tractaran com a objectes diferents, encara que hi haja una coincid\u00e8ncia amb tots i cadasc\u00fan dels seus valors. \u00c9s per aix\u00f2 que es recomana utilitzar nom\u00e9s una \u00fanica inst\u00e0ncia per cada objecte que l\u2019aplicaci\u00f3 necessite. Si una inst\u00e0ncia ja est\u00e0 guardada, caldr\u00e0 recuperar-la de la Base de Dades, ja que les successives recuperacions d\u2019un mateix objecte retornen sempre la mateixa refer\u00e8ncia en mem\u00f2ria. Si la inst\u00e0ncia no estiguera guardada, caldria instanciar-la una \u00fanica vegada fent servir qualsevol forma d\u2019instanciaci\u00f3 suportada pel llenguatge (utilitzant, per exemple, una sent\u00e8ncia new seguida del constructor). A banda de la instanciaci\u00f3 d\u2019objectes i del concepte d\u2019identitat utilitzat, DB4O afegeix un nou concepte que caldr\u00e0 tenir en compte a l\u2019hora d\u2019implementar aplicacions que la utilitzen. Es tracta del concepte d\u2019activaci\u00f3. Per tal d\u2019evitar un temps de proc\u00e9s i consum de mem\u00f2ria excessius a l\u2019hora de treballar amb estructures de dades molt complexes i ramificades, DB4O ofereix diverses formes de recuperar un objecte sense haver d\u2019instanciar tots i cadascun dels seus objectes interns. DB4O ofereix la possibilitat d\u2019indicar la profunditat a la qual es vol fer la recuperaci\u00f3. Per defecte, la profunditat utilitzada \u00e9s 5, per\u00f2 podem canviar-ho a voluntat. Una vegada instanciat un objecte podem canviar la seua profunditat d\u2019activaci\u00f3 de forma din\u00e0mica en qualsevol moment, de manera que disposem d\u2019un mecanisme per accedir a tots els objectes que l\u2019aplicaci\u00f3 requereix en el moment que siga necessari sense haver de malgastar recursos. 1.1 - Instal\u00b7laci\u00f3 de DB4O DB4O va ser desenvolupat per la companyia db4objects, Inc . En 2008 va ser adquirida per l'empresa Versant , que va continuar desenvolupant-lo com a Open Source. En 2012, Versant va ser adquirida per la companyia Actian , que ja no ha continuat desenvolupant-lo com a Open Source, optant per un altre producte de pagament. A pesar de l'anterior, utilitzarem DB4O, encara que siga una versi\u00f3 creada ja fa un temps. Per una banda ens far\u00e0 falta el driver, el controlador. El podem obtenir des de la p\u00e0gina que Actian mant\u00e9 per a les versions anteriors: http://supportservices.actian.com/versant/default.html Dins d'aquesta p\u00e0gina veurem un apartat de db4o (on diu que ja no s'actualitzar\u00e0), per\u00f2 igual podrem baixar-nos el packet per a Java: https://www.dropbox.com/s/s6farl3dqez7e1r/db4o-8.0.276.16149-java.zip?dl=0 Ens descarreguem aquest zip, del qual realment l'unic que ens interessa \u00e9s el seg\u00fcent fitxer, situat en el directori libs db4o-8.0.249.16098-core-java5.jar Aquest \u00e9s el driver que incorporarem al nostre projecte. Per una altra banda, buscarem un entorn dins de IntelliJ per a poder veure les dades d'una Base de Dades de DB4O. \u00c9s tan senzill com anar a la \u00e0gina de plugins ( File - > Settings -> Plugins ) i en la pestanya Marketplace buscar db4o Una vegada instal\u00b7lat conv\u00e9 una reinicialitzaci\u00f3 de IntelliJ, i trobarem una entrada en View - > Tool windows -> db4o , que far\u00e0 que s'\u00f2biga una finestra a la part de baix per a poder inspeccionar els objectes d'una Base de Dades db4o, com veurem un poc m\u00e9s avant 1.2 - Funcionalitat b\u00e0sica Treballarem sobre un exemple anterior, el dels empleats, per\u00f2 incorporant m\u00e9s dades, com els tel\u00e8fons, els correus electr\u00f2nics, etc, per veure que podem guardar una classe un poc m\u00e9s complicada en la BD Orientada a Objectes. En un projecte nou, anomenat Tema6 , anem a incorporar el driver de DB4O db4o-8.0.249.16098-all-java5.jar Per organitzar-lo millor creem un paquet anomenat classesEmpleat , que ens servir\u00e0 per a fer tots els exemples. Ens crearem la classe Empleat , i les classes Adreca i Telefon que utilitzar\u00e0 aquella. Constru\u00efm les classes de la manera m\u00e9s c\u00f2moda. Aix\u00f2 s\u00ed, a Empleat li afegirem dos constructors per a fer m\u00e9s c\u00f2moda la introducci\u00f3 d'Empleats amb poques dades, ja veurem per qu\u00e8. class Adreca (var carrer: String?, var codipostal: String?, var poblacio: String?) class Telefon( var mobil : Boolean , var numero: String) Ara ja va Empleat : class Empleat ( var nif: String? , var nom: String? , var departament: Int? , var edat: Int? = 0 , var sou: Double? = 0.0 , var foto: Array<Byte>? , var curriculum: Array<Char>? , var adreca: Adreca? , var correus_e: Array<String>? , var telefons : Array<Telefon>? ) { constructor() : this(null,null,null,null,null,null,null,null,null,null) constructor(nif: String) : this(nif,null,null,null,null,null,null,null,null,null) } Com coment\u00e0vem anteriorment, hi ha una versi\u00f3 servidor, per\u00f2 que nosaltres ens conformarem amb la versi\u00f3 integrada ( embedded ). En el cas de la versi\u00f3 servidor utilitzar\u00edem la classe Db4o per a fer la connexi\u00f3. Com que nosaltres farem servir la versi\u00f3 integrada, utilitzarem la classe Db4oEmbedded . Connexi\u00f3 \u00c9s tan senzill com cridar des de la classe Db4oEmbedded el m\u00e8tode est\u00e0tic openFile() passant-li com a par\u00e0metre el nom del fitxer. A partir d\u2019aquest moment, es mantindr\u00e0 oberta una transacci\u00f3 que continuar\u00e0 activa fins que tanquem amb el m\u00e8tode close() . val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") Inserci\u00f3 Per a guardar un objecte utilitzem el m\u00e8tode store(objecte) Provem a introduir un empleat. Guardeu el seg\u00fcent programa en Exemple1_InserirEmpleat.kt . Guardeu-lo en el paquet exemples import com.db4o.Db4oEmbedded import classesEmpleat.Empleat import classesEmpleat.Adreca import classesEmpleat.Telefon fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") var e = Empleat(\"11111111a\",\"Albert\",10,45,1000.0,null,null,null,null,null) // les dades m\u00e9s complicades les introdu\u00efm de forma especial e.adreca = Adreca(\"C/ Major, 7\", \"12001\", \"Castell\u00f3\") e.correus_e = arrayOf(\"alu11111111a@ieselcaminas.org\") e.telefons = arrayOf(Telefon(true, \"666777888\"), Telefon(false, \"964112233\")) bd.store(e); bd.close(); } S\u00ed que ha guardat l'objecte. Mirem-lo des de la finestra de DB4O: On hem obert la BD apretant el bot\u00f3 Open (de vegades no mostra les dades dient que This view is not available until indexes are built . Ho podem solucionar reiniciant IntelliJ i aix\u00ed obligant a reconstruir els \u00edndex). I hem apretat el bot\u00f3 Get Objects tenint seleccionada la classe Empleats . En finalitzar d'observar les dades des de la finestra DB4O \u00e9s convenient tancar la connexi\u00f3 . Si no la tanquem, quan anem a executar qualsevol programa que accedisca, ens donar\u00e0 error, avisant que la Base de Dades est\u00e0 bloquejada ( com.db4o.ext.DatabaseFileLockedException ). Per tant, haurem de tenir especial atenci\u00f3 a tancar la connexi\u00f3 a la Base de Dades. Podria passar que ens donara un error el programa, i la connexi\u00f3 s'haja quedat oberta. Segurament el m\u00e9s oport\u00fa ser\u00e0 intentar tancar el programa, o tancar IntelliJ, i d'aquesta manera desbloquejarem la Base de Dades. El m\u00e8tode commit obliga a guardar les dades cap al contenidor i activa de nou una transacci\u00f3 per a les properes operacions, per tant \u00e9s convenient anar utilitzant-lo despr\u00e9s d'una s\u00e8rie d'actualitzacions. Anem a posar algunes dades m\u00e9s, per a tenir un poc m\u00e9s de joc. Concretament seran dues empleades m\u00e9s. Copieu el seg\u00fcent codi al fitxer Exemple1_1_InserirMesEmpleats.kt import classesEmpleat.Adreca import classesEmpleat.Empleat import classesEmpleat.Telefon import com.db4o.Db4oEmbedded fun main() { val bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val e = Empleat(\"22222222b\", \"Berta\", 10, 35, 1700.0, null, null, null, null, null) val f = Empleat(\"33333333c\", \"Cl\u00e0udia\", 20, 37, 1500.0, null, null, null, null, null) //les dades m\u00e9s complicades les introdu\u00efm de forma especial e.adreca = Adreca (\"C/ Enmig, 7\", \"12001\", \"Castell\u00f3\") val corr = arrayOf( \"alu22222222b@ieselcaminas.org\", \"berta@gmail.com\" ) e.correus_e = corr val tels = arrayOf(Telefon(true,\"666555444\"), Telefon(false,\"964223344\")) e.telefons = tels f.adreca = Adreca (\"C/ de Dalt, 7\", null, \"Borriana\") val corr2 = arrayOf(\"alu33333333c@ieselcaminas.org\") f.correus_e = corr2 bd.store(e) bd.store(f) bd.close() } Consulta b\u00e0sica En la seg\u00fcent pregunta, veurem les maneres de fer una consulta, per\u00f2 ara anem a veure la forma m\u00e9s senzilla, que \u00e9s la realitzada a trav\u00e9s del m\u00e8tode anomenat queryByExample . Aquest m\u00e8tode rep per par\u00e0metre un objecte del tipus a cercar, que far\u00e0 d\u2019exemple o patr\u00f3 per trobar totes aquelles inst\u00e0ncies emmagatzemades coincidents amb les dades del patr\u00f3. El patr\u00f3 que es passe per par\u00e0metre no haur\u00e0 de tenir totes les dades complimentades, sin\u00f3 nom\u00e9s aquelles de les quals se\u2019n desitge la coincid\u00e8ncia. Aix\u00ed, per exemple, si passem un objecte d'Empleat amb un \u00fanic atribut introdu\u00eft (el nif ), queryByExample retornar\u00e0 totes aquelles inst\u00e0ncies que tinguen per nif el valor entrat. Per aquesta ra\u00f3 vol\u00edem un constructor amb nom\u00e9s el nif, per a poder buscar l'empleat amb aquest nif amb queryByExample() . El retorn es fa en un objecte de tipus ObjectSet , una classe que implementa la interf\u00edcie List de Java i tamb\u00e9 la interf\u00edcie Iterable , de manera que siga possible rec\u00f3rrer el contingut utilitzant els m\u00e8todes next i hasNext . Tamb\u00e9 podem utilitzar el bucle for (el del foreach ). En el seg\u00fcent exemple es veu com una vegada obtingut l'objecte, es pot accedir molt f\u00e0cilment a tota la informaci\u00f3. Copieu-lo al fitxer Kotlin Exemple2_ConsultaUnEmpleat.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() as Empleat println( \"Nif: \" + e.nif + \". Nom: \" + e.nom + \". Poblaci\u00f3: \" + e.adreca?.poblacio ) if (e.correus_e != null) print(\"Primer correu: \" + e.correus_e?.get(0) + \".\") if (e.telefons != null) print(\"Primer tel\u00e8fon: \" + e.telefons!![0].numero + \".\") println() } bd.close(); } Observeu com no hem utilitzat un bucle per a rec\u00f3rrer la llista, sin\u00f3 un if. Aix\u00f2 \u00e9s perqu\u00e8 en aquest cas concret sabem a priori que en cas de trobar alguna inst\u00e0ncia, nom\u00e9s ser\u00e0 una. Aquest seria el resultat: Nif: 11111111a. Nom: Albert. Poblaci\u00f3: Castell\u00f3 Primer correu: alu11111111a@ieselcaminas.org. Primer tel\u00e8fon: 666777888. Esborrat Per a poder fer una actualitzaci\u00f3 o esborrat d'algun objecte de la Base de Dades, aquest s'ha de correspondre amb algun objecte del programa Java o Kotlin, \u00e9s a dir, l'objecte ha de ser persistent. Aquesta correspond\u00e8ncia pot ser perqu\u00e8 un objecte nou l'hem guardat amb store() (i continua \"viu\"), o perqu\u00e8 l'hem llegit de la BD (millor dit, hem llegit una llista i despr\u00e9s hem fet l'assignaci\u00f3 a un objecte). L\u2019eliminaci\u00f3 dels objectes s\u2019aconsegueix amb el m\u00e8tode delete . Per defecte, DB4O elimina nom\u00e9s l'objecte que es passa com a par\u00e0metre, per\u00f2 no els objectes que aquest puga contenir. Si un objecte cont\u00e9 un altre objecte, com succeeix amb les inst\u00e0ncies Empleat i Adreca i Telefon , aix\u00f2 pot convertir-se en un gran problema, ja que s\u00f3n objectes que normalment no es manipularan per separat i, en cas que no s\u2019esborren amb el seu propietari, continuaran indefinidament en la Base de Dades. Per evitar-lo haur\u00edem de configurar per a que esborre en cascada . Mirem un exemple en el qual esborrem un empleat. En el comentari teniu el moment en que encara no es corresponen, i per tant no es pot esborrar. Recordeu que despr\u00e9s d'aquest exemple, quedar\u00e0 inconsistent la informaci\u00f3. Si no voleu fer-lo, poder saltar-vos-el. De tota manera, si el feu i queda inconsistent la informaci\u00f3 sempre podem esborrar la Base de Dades i tornar a executar Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt . Si teniu ganes de fer-lo, guardeu-lo en el fitxer Exemple3_EsborratDefectuos.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val patro = Empleat(\"22222222b\") // Si pos\u00e0rem ac\u00ed db.delete(patro) no tindr\u00eda efecte, perqu\u00e8 e no es // correspon amb cap inst\u00e0ncia de la BD val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() bd.delete(e) } bd.close() } Com que no hem esborrat en cascada , si despr\u00e9s mirem des de la perspectiva OME, comprovarem que encara existeixen els objectes adre\u00e7a i tel\u00e8fon, i que ara no correspondran a cap empleat. Haur\u00edem d'aprofitar el moment per a esborrar des de la perspectiva OME les inst\u00e0ncies de Adreca i Telefon que corresponien a l'empleat que hem esborrat, per deixar-lo consistent. En les seg\u00fcents imatges es mostra aquest fet: Ja no existeix l'objete Empleat corresponent a Berta, per\u00f2: encara existeix la seua adre\u00e7a (C/Enmig, 7 de Castell\u00f3) i els seua tel\u00e8fons (666555444 i 964223344) Per a poder esborrar en cascada , en el moment d\u2019obrir el fitxer contenidor haurem d'especificar-lo posant-li una configuraci\u00f3 com veurem a continuaci\u00f3. No \u00e9s possible modificar la configuraci\u00f3 de forma din\u00e0mica. A m\u00e9s, malauradament, la configuraci\u00f3 no es guarda amb el fitxer contenidor, sin\u00f3 que cada vegada que obrim, haurem d'especificar-li la configuraci\u00f3 desitjada. En aquesta configuraci\u00f3 li direm que la classe Empleat esborra en cascada, \u00e9s a dir, que quan esborrem un objecte, els objectes \"subordinats\" (de les classes Adreca i Telefon ) tamb\u00e9 s'esborraran. Copieu el seg\u00faent codi en un fitxer anomenat Exemple4_EsborratCorrecte.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val conf = Db4oEmbedded.newConfiguration() conf.common().objectClass(\"classesEmpleat.Empleat\").cascadeOnDelete(true) val bd = Db4oEmbedded.openFile(conf,\"Empleats.db4o\") val patro = Empleat(\"33333333c\") // Si pos\u00e0rem ac\u00ed db.delete(patro) no tindr\u00eda efecte, perqu\u00e8 e no es // correspon amb cap inst\u00e0ncia de la BD val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() bd.delete(e) } bd.close() } En les seg\u00fcents imatges es mostra com ara s\u00ed que ha esborrat en cascada: Hem esborrat a Cl\u00e0udia I tamb\u00e9 ha desaparegut la seua adre\u00e7a (C/ de Dalt de Borriana). Com que no tenia tel\u00e8fons, continuen els mateixos d'abans Modificaci\u00f3 Per a modificar un objecte de la Base de Dades primer haurem de tenir un objecte de Java que es corresponga amb ell (igual que en l'esborrat). Despr\u00e9s de modificar-lo, nom\u00e9s l'haurem de guardar amb store() . Hem de parar atenci\u00f3 a que si el que volem modificar \u00e9s d'una subclasse, haurem de modificar en cascada , sin\u00f3 no tindr\u00e0 efecte. Ho farem indicant cascadeOnUpdate(true) a la configuraci\u00f3 amb qu\u00e8 obrirem el fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple5_ModificarCascada.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.config.EmbeddedConfiguration import classesEmpleat.Adreca import classesEmpleat.Empleat fun main() { val conf = Db4oEmbedded.newConfiguration() conf.common().objectClass(\"classesEmpleat.Empleat\").cascadeOnUpdate(true) val bd = Db4oEmbedded.openFile(conf, \"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { var e = llista.next() if (e.sou != null) { e.sou = e.sou.toString().toDouble() + 200.0 } val adr = e.adreca adr?.carrer = \"Pl. Rei en Jaume, 15\" adr?.codipostal = \"12002\" e.adreca = adr bd.store(e) } bd.close() } En la imatge es veu que en fer l'actualitzaci\u00f3 en cascada s\u00ed que s'han guardat els canvis, i la primera adre\u00e7a (que \u00e9s la corresponent a Albert) s'ha modificat. La restricci\u00f3 que hem comentat abans de que hem de tenir un objecte de Java que es corresponga amb ell (que ocupa els casos d'esborrat i modificaci\u00f3), l'hem de tenir molt present. I hem d'anar amb compte, perqu\u00e8 quan es tanca la BD es perd tota correspond\u00e8ncia. El seg\u00fcent exemple \u00e9s id\u00e8ntic a l'anterior, per\u00f2 es tanca i es torna a obrir la BD despr\u00e9s d'haver assignat a e l'objecte, i abans de guardar-lo; per tant L'OBJECTE EST\u00c0 SEPARAT (ja no est\u00e0 associat a un objecte de la Base de Dades). En principi el que voldr\u00edem \u00e9s modificar les dades de l'empleat existent, per\u00f2 en realitat hem introdu\u00eft un nou empleat (amb el mateix nif, nom, ...), i per tant molt perill\u00f3s perqu\u00e8 estem duplicant la informaci\u00f3. Observeu que, com que nom\u00e9s es vol modificar el sou, no cal actualitzar en cascada. Si voleu provar l'exemple, gaurdeu el seg\u00fcent codi en el fitxer Kotlin Exemple6_Modificaci\u00f3Incorrecta.kt . I recordeu que la Base de Dades haur\u00e0 quedat malament, i per tant el millor seia esborrar-la i tornar a executar els exemples Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { var bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { var e = llista.next() if (e.sou != null) { e.sou = e.sou.toString().toDouble() + 200.0 } bd.close() // Tanquem i tornem a obrir la BD, per veure que hem // perdut la correspond\u00e8ncia de e amb l'objecte de la BD bd = Db4oEmbedded.openFile(\"Empleats.db4o\") bd.store(e) } bd.close() } Ara el contingut de la Base de Dades \u00e9s aquest: On es veu que hem creat un nou objecte, en compte de modificar el que ja existia. I el mateix amb l'adre\u00e7a i els tel\u00e8fons En cas que tanquem la BD i vulguem modificar o esborrar un objecte haurem de tornar a connectar amb ell. I en el cas de la inserci\u00f3, abans d'inserir, podr\u00edem comprovar que no existeix (per exemple que no existeix cap empleat amb aquest nif). 1.3 - Consultes DB4O disposa de tres formes de realitzar consultes. Totes elles s\u00f3n de tipus NoSQL. Nota Si hav\u00edeu fet tots els exemples anteriors, potser siga millor esborrar Empleats.db4o i tornar a executar Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt per a crear-les de nou. M\u00e8tode Query By Example La primera forma ja s\u2019ha comentat, \u00e9s la que s\u2019anomena consulta basada en un exemple o \u201c query by example \u201d. Consisteix, com ja hem vist, en trobar totes les inst\u00e0ncies guardades que coincidesquen amb els valors no nuls i diferents de zero (en cas que siguen num\u00e8rics) d\u2019un patr\u00f3 o exemple passat per par\u00e0metre. Si, per exemple, volem traure els empleats del departament 10 que s\u00f3n de Castell\u00f3, n\u2019hi hauria prou amb crear el patr\u00f3 que posem a continuaci\u00f3. Copieu el seg\u00fcent codi al fitxer Exemple11_Consulta_QueryByExample.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Adreca import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded. openFile(\"Empleats.db4o\") val patro = Empleat() patro.departament = 10 patro.adreca = Adreca (null, null, \"Castell\u00f3\") val llista = bd.queryByExample<Empleat>(patro) for (e in llista) { System.out.println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \". Departament: \" + e.departament + \". Poblaci\u00f3: \" + e.adreca?.poblacio ) } bd.close() } cosa que donar\u00e0 com a resultat el seg\u00fcent, que es pot comprovar que s\u00f3n del departament 10 i de Castell\u00f3: Nif: 11111111a. Nom: Albert. Departament: 10. Poblaci\u00f3: Castell\u00f3 Nif: 22222222b. Nom: Berta. Departament: 10. Poblaci\u00f3: Castell\u00f3 Seguint aquest raonament, per obtenir tots els empleats de l\u2019aplicaci\u00f3 caldr\u00e0 passar un patr\u00f3 empleat sense valors ( bd.queryByExample(Empleat() ) ), i si el que desitgem \u00e9s obtenir tots els objectes emmagatzemats a la base de dades, el que haurem de passar com a par\u00e0metre \u00e9s un valor null ( bd.queryByExample(null) ). Com podeu veure, resulta un sistema molt simple. Ara b\u00e9, tamb\u00e9 t\u00e9 moltes limitacions en consultes m\u00e9s complexes, i fins i tot poden resultar impossibles. Posem alguns exemples en els quals no funciona aquest tipus de consulta: \u00c9s impossible trobar tots els empleats que no tinguen algun camp assignat encara (\u00e9s a dir, null) a causa del mecanisme utilitzat: nom\u00e9s s\u2019avaluen els camps no nulls. Tampoc podr\u00edem trobar aquells empleats que cobren m\u00e9s de 1300\u20ac . En aquest tipus de consulta nom\u00e9s podem buscar igualtats. Com es basa en la coincid\u00e8ncia, no podrem fer consultes que puguen agafar un de dos o m\u00e9s valors determinats. Per exemple, agafar els empleats que s\u00f3n de Castell\u00f3 o Borriana. M\u00e8tode Native Queries DB4O disposa d\u2019un sistema molt m\u00e9s potent anomenat Native Queries . \u00c9s f\u00e0cil deduir que es tracta d\u2019un sistema vinculat directament al mateix llenguatge de programaci\u00f3. De fet, es tracta de construir un procediment en el qual s'avaluen els objectes i es decideix quins objectes acompleixen la condici\u00f3 i quins no. Per a fer la consulta haurem de crear una classe que implemente una interf\u00edcie anomenada Predicate . Aquesta interf\u00edcie consta d'un \u00fanic m\u00e8tode declarat anomenat match . La classe nostra que implementar\u00e0 Predicate haur\u00e0 de sobreescriure el m\u00e8tode match(), i en aquest m\u00e8tode podrem posar una s\u00e8rie de sent\u00e8ncies Kotlin i dir si cada objecte de la Base de Dades acompleix o no la condici\u00f3 tornant respectivament true o false. En el seg\u00fcent exemple creem una classe anomenada EmpleatsPerPoblacio (que implementa Predicate ), a la qual se li pot passar en el constructor un vector de cadenes de car\u00e0cters amb els noms de les poblacions de les quals volem els empleats. En la implementaci\u00f3 del m\u00e8tode match tornarem cert si l'empleat \u00e9s d'alguna de les poblacions, i fals en cas contrari. Com que utilitzem el mateix llenguatge de programaci\u00f3, la pot\u00e8ncia \u00e9s molt elevada. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple12_Consula_NativeQuery_1.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Predicate import classesEmpleat.Empleat class EmpleatsPerPoblacio(pobles: Array<String>) : Predicate<Empleat>() { val poblacions = pobles override fun match(emp: Empleat): Boolean { return (emp.adreca?.poblacio in poblacions) } } fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val pobl = arrayOf(\"Castell\u00f3\", \"Borriana\") val llista = bd.query(EmpleatsPerPoblacio(pobl)) for (e in llista) { println(e.nom + \" (\" + e.adreca?.poblacio + \")\") } bd.close() } Observeu que una vegada definida la classe, podem fer-la servir en una Query per realitzar una consulta espec\u00edfica. En l'exemple, s'obtenen tots els empleats que s\u00f3n de Castell\u00f3 o de Borriana. En variar la llista de poblacions obtindrem uns objectes empleat o uns altres. En el m\u00e8tode match, que \u00e9s qui diu si un element Empleat compleix la condici\u00f3, es comprova si la poblaci\u00f3 de l'empleat (que est\u00e0 dins d'adre\u00e7a, i per tant s'accedeix amb emp.adreca?.poblacio ) est\u00e0 dins de l'array de poblacions. Com que es tracta d\u2019una interf\u00edcie amb un \u00fanic m\u00e8tode a implementar, no caldr\u00e0 que implementem sempre noves classes per a cada consulta diferent, sin\u00f3 que podem fer servir classes anidades an\u00f2nimes (anonymous nested class), per a fer-lo molt m\u00e9s curt, definint la classe en el oment d'utilitzar-la. Mirem-ho en un altre exemple, en el qual es buscaran els empleats que tinguen el sou entre dos valors determinats. Constru\u00efm la classe Predicate en el mateix lloc on s'utilitza, en el query() , i no abulta molt perqu\u00e8 nom\u00e9s t\u00e9 el m\u00e8tode match() . En el m\u00e8tode match() \u00e9s on es comprova la condici\u00f3. Copieu el seg\u00fcent codi en el fitxer Exemple13_NativeQuery_2.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Predicate import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val max = 1500.0 val min = 1000.0 val llista = bd.query(object: Predicate<Empleat>() { override fun match(emp: Empleat): Boolean { if (emp.sou.toString().toDouble() <= max && emp.sou.toString().toDouble() >= min) return true else return false } }) for (e in llista) { System.out.println(e.nom + \" (\" + e.sou + \")\") } bd.close() } En tractar-se d\u2019una interf\u00edcie amb un \u00fanic m\u00e8tode a implementar, no caldr\u00e0 que implementem sempre noves classes per a cada consulta diferent, sin\u00f3 que podem fer servir classes imbricades an\u00f2nimes ( anonimous nested class ). Recordeu que les classes imbricades poden treballar directament amb tots els atributs (tinguin l\u2019\u00e0mbit que tinguin) de la classe que les contingui i que les classes an\u00f2nimes es defineixen a l\u2019interior d\u2019un m\u00e8tode qualsevol. M\u00e8tode SODA Existeix encara una altra forma de definir consultes. DB4O l\u2019anomena SODA ( Simple Object Database Access ), i es pot considerar com la forma d\u2019accedir a l\u2019estructura interna de la base de dades a baix nivell per tal de seleccionar els nodes de dades que complesquen uns determinats requisits i que acabaran determinant el resultat de la consulta. De fet, segons indiquen els autors, \u00e9s la forma de consulta m\u00e9s r\u00e0pida de les tres. La idea fonamental de SODA \u00e9s construir les consultes com un recorregut d\u2019una xarxa de nodes enlla\u00e7ats. Els nodes de la consulta s\u2019estructuren de forma semblant a les classes emmagatzemades a la base de dades, de manera que el cam\u00ed seguit en avaluar la consulta, node a node, es repeteix en les inst\u00e0ncies emmagatzemades, la qual cosa permet accedir als valors per avaluar de forma r\u00e0pida. El cam\u00ed s\u2019especifica utilitzant el m\u00e8tode descend() per mitj\u00e0 del qual seleccionem la branca de l\u2019estructura de classes que vulguem fer refer\u00e8ncia. Per exemple, si ens trobem en el node de la classe Empleat i volgu\u00e9rem fer refer\u00e8ncia al nom de la poblaci\u00f3 que en l\u2019estructura de classes es troba a empleat.adreca.poblacio , haur\u00edem de fer node.descend(\"adreca\").descend(\"poblacio\") El resultat de la sent\u00e8ncia anterior \u00e9s un node focalitzat a l\u2019atribut poblaci\u00f3 continguda a l\u2019adre\u00e7a de l'empleat. Cada node pot estar afectat per una restricci\u00f3, per una ordenaci\u00f3 i/o per una operaci\u00f3 amb una altre node. Les restriccions permeten seleccionar o desestimar les inst\u00e0ncies que es vagen comprovant. Les ordenacions, com \u00e9s natural, forcen l\u2019ordre de les inst\u00e0ncies seleccionades d\u2019acord amb els valors de l\u2019atribut representat pel node afectat. Finalment, les operacions marquen quin ser\u00e0 el seg\u00fcent node a avaluar, el qual actuar\u00e0 tamb\u00e9 com a filtre dels objectes de la selecci\u00f3. Les restriccions es veuran afectades per una o m\u00e9s relacions que permetran modificar la comparaci\u00f3 i sentenciar en favor o en contra de la selecci\u00f3 d\u2019una inst\u00e0ncia. Per defecte, la relaci\u00f3 avaluada \u00e9s la d\u2019igualtat. Per exemple, si partim d\u2019un node que representa el NIF d\u2019un empleat, podem definir la relaci\u00f3 d\u2019igualtat seg\u00fcent: node.constrain(\"11111111a\") Mirem com quedaria el programa que selecciona \u00fanicament l'empleat amb el nif anterior. Guardeu el seg\u00fcent codi al fitxer Exemple14_QuerySoda_1.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query () //node arrel. var node = q.descend (\"nif\") //arribem a l'altura del nif, que \u00e9s on posem la restricci\u00f3 node.constrain(\"11111111a\") val llista = q.execute<Empleat>() for (e in llista){ println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \" (\" + e.sou + \")\") } bd.close() } En realitat intentar\u00e0 agafar en principi tots els objectes de la Base de Dades, i recordem que tenim objectes Empleat , Adreca i Telefon . Per\u00f2 observeu que no cal especificar que siga \u00fanicament objectes de la classe Empleat , perqu\u00e8 \u00e9s l'\u00fanica classe que t\u00e9 una propietat anomenada nif , per tant \u00fanicament selccionar\u00e0 empleats Per\u00f2 si la relaci\u00f3 ha de ser una comparaci\u00f3 de tipus major que , menor o igual que , ... , caldr\u00e0 especificar-les expressament. La manera ser\u00e0 especificant un m\u00e8tode de la restricci\u00f3. Les possibilitats seran: Major: greater() Si suposem que partim d\u2019un node focalitzat al sou d\u2019un empleat i volem la condici\u00f3 que el sou siga major estrictament que 1300. S\u2019indicaria d'aquesta manera: node.constrain(1300).greater() Menor: smaller() Si volem que el sou siga estrictament menor que 1500: node.constrain(1500).smaller() Major o igual, menor o igual: equal() (despr\u00e9s del greater o smaller) Si ara volem que el sou siga menor o igual que 1500: node.constrain(1300).smaller().equal() Que comence per: startsWith(boolean) Si partim d'un node focalitzat al nom de l'empleat i volem els que comencen per A : node.constrain(\"A\").startsWith(true) Si en el par\u00e0metre boole\u00e0 posem true, haur\u00e0 de coincidir exactament el principi. Si posem false, no distingir\u00e0 entre maj\u00fascules i min\u00fascules. Per a unir restriccions: or(restriccio) and(restriccio) . Per a negar not() Per exemple, si partim d\u2019un node focalitzat al nom de l'empleat, podem seleccionar tots els que comencen per A o per B , fent: var constr1 = node.constrain(\"A\").startsWith() val constr2 = node.constrain(\"B\").startsWith() constr1.or(constr2) Si posem m\u00e9s d'una restricci\u00f3 (m\u00e9s d'un constrain), s'hauran de complir totes, i per tant actua com un and A banda de les restriccions, si volem ordenar de forma ascendent o descendent, ho indicarem amb els m\u00e8tode orderAscending() o orderDescending() del node pel mig del qual volem ordenar . Mirem un parell d'exemples per veure com es posa tot en joc. Anem a construir la sent\u00e8ncia que permeta seleccionar tots els empleats amb un sou que oscil\u00b7le entre un rang de valors definits (estrictament major que 1000, i menor o igual que 1500, per exemple) ordenats de forma descendent per sou. Guardeu-lo al fitxer Exemple15_QuerySoda_2.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query() //node arrel. var node = q.descend(\"sou\") //arribem a l'altura del sou, que \u00e9s on posem la restricci\u00f3 node.constrain(1000).greater().and(node.constrain(1500).smaller().equal()) node.orderDescending() val llista = q.execute<Empleat>() for (e in llista) { println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \" (\" + e.sou + \")\") } bd.close() } I ara els empleats del departament 10 que s\u00f3n de Castell\u00f3. Podem utilitzar el mateix objecte node per anar afegint restriccions, per\u00f2 haurem de cuidar de localitzar-lo al lloc oport\u00fa. Guardeu-llo amb el nom Exemple16_QuerySoda_3.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query() //node arrel. var node = q.descend(\"departament\") //arribem a l'altura del departament, que \u00e9s on posem la restricci\u00f3 node.constrain(10) node = q.descend(\"adreca\").descend(\"poblacio\") //i ara arribem a l'altura de la poblaci\u00f3 de l'adre\u00e7a node.constrain(\"Castell\u00f3\") val llista = q.execute<Empleat>() for (e in llista) { println(\"Nom: \" + e.nom + \". Poblaci\u00f3: \" + e.adreca?.poblacio + \". Departament: \" + e.departament) } bd.close() } Tot i que cal ens proporciona 3 maneres de fer les consultes, i al final aquestes poden ser potents, no \u00e9s capa\u00e7 de tenir tota l\u2019expressivitat d\u2019un llenguatge com OQL. No disposa de funcions d\u2019agregat (SUM, AVG, MAX, MIN, ...), ni es poden expressar relacions entre inst\u00e0ncies. \u00c9s l\u2019aplicaci\u00f3 la que haur\u00e0 de fer-se responsable que aix\u00f2 siga possible. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Les Bases de Dades Orientades a Objectes"},{"location":"3__bases_de_dades_orientades_a_objectes/#1-bases-de-dades-orientades-a-objectes","text":"L'\u00faltima alternativa que veurem per a guardar els objectes de Java ser\u00e0 fer servir directament una Base de Dades Orientada a Objectes . En principi semblaria que es tracta de la millor soluci\u00f3 ja que no hi ha cap tipus de desfasament, i es podran guardar directament els objectes. Encara aix\u00ed, aquesta modalitat de bases de dades presenta certes peculiaritats que cal tenir molt en compte. Actualment trobem al mercat dos tipus de Bases de Dades Orientades a Objecte. Les que compleixen l\u2019est\u00e0ndard proposat per l\u2019 ODMG (Object Database Management Group) a finals de l\u2019any 2000 Les anomenades bases de dades de tipus NoSQL , iniciatives tecnol\u00f2giques posteriors. En realitat el terme NoSQL (Not Only SQL) es refereix a totes aquelles que no segueixen el Model Relacional, i s'inclourien BD Orientades a Objectes, BD XML, i tamb\u00e9 altres tipus com les documentals, les BD clau-valor, i algun altre tipus. L\u2019ODMG es va desfer l\u2019any 2001, despr\u00e9s de culminar l\u2019est\u00e0ndard anomenat ODMG 3.0. Encara que ja ha passat molt de temps, es tracta d\u2019un est\u00e0ndard molt infrautilitzat . Els llenguatges que especifica (ODL i OQL), encara que tenen una pot\u00e8ncia molt gran i permeten una adaptaci\u00f3 real a la sintaxi habitualment utilitzada per la majoria de llenguatges Orientats a Objectes, presenta una enorme influ\u00e8ncia del paradigma relacional . Aquesta \u00e9s segurament la causa de que hi hagen pocs productes actuals que seguisquen aquest model. I \u00e9s una pena, perqu\u00e8 a banda de guardar c\u00f2modament els objectes, el OQL ens permetria buscar la informaci\u00f3 de forma f\u00e0cil i potent. En els \u00faltims anys han aparegut algunes iniciatives noves que proposen un canvi de plantejament en la gesti\u00f3 dels objectes: les Bases de Dades NoSQL . Es tracta d\u2019un plantejament trencador que vol aprofitar-se de l\u2019estructura interna pr\u00f2pia dels objectes per organitzar la persist\u00e8ncia a mode de punters o refer\u00e8ncies internes, de manera que una vegada guardats els objectes, no es perda la potencialitat que suposa aquesta organitzaci\u00f3. \u00c9s una iniciativa molt jove que sembla cridada a ser la seg\u00fcent generaci\u00f3 en els Sistemes Gestors de Bases de Dades perqu\u00e8 d\u00f3na una resposta molt adequada a l\u2019hora de representar escenaris complexos en els quals les bases de dades cl\u00e0ssiques (relacionals) han fracassat. Ens referim a escenaris amb components gr\u00e0fics o documentals, o a situacions amb informaci\u00f3 extremadament complexa que cal analitzar ( business intelligence , per exemple). DB4O ( Database for Objects ) \u00e9s una de les iniciatives amb llic\u00e8ncia GPL m\u00e9s actives, que implementa una base de dades 100% Orientada a Objectes i basada en el concepte NoSQL . Es tracta d\u2019una base de dades lleugera amb una versi\u00f3 integrada en el propi llenguatge Java ( Embedded ). Aix\u00f2 fa que la seua instal\u00b7laci\u00f3 siga nul\u00b7la, ja que nom\u00e9s cal incorporar a la nostra aplicaci\u00f3 les biblioteques que podem trobar a la p\u00e0gina de l\u2019empresa Versant , per disposar d\u2019una base de dades operativa. I pel seu petit volum i extrema efici\u00e8ncia, s\u2019utilitza tamb\u00e9 molt en aplicacions m\u00f2bils i serveis web. Existeix tamb\u00e9 un versi\u00f3 distribu\u00efda per instal\u00b7lar en un servidor, per\u00f2 la versi\u00f3 integrada ser\u00e0 suficient per agafar les nocions b\u00e0siques que ens cal explicar. L\u2019\u00das de DB4O no precisa crear cap model de dades espec\u00edfic per configurar l\u2019estructura que suporte les dades en SGBDOO. De fet, utilitza la informaci\u00f3 interna dels objectes per construir de forma din\u00e0mica aquesta estructura. L\u2019extracci\u00f3 d\u2019aquesta informaci\u00f3 \u00e9s possible gr\u00e0cies a les caracter\u00edstiques reflexives dels llenguatges de programaci\u00f3 als quals d\u00f3na suport (Java i C#). DB4O no guarda els objectes basant-se en els seus valors, sin\u00f3 en les seues refer\u00e8ncies en mem\u00f2ria. Dos objectes ubicats en llocs diferents de la mem\u00f2ria RAM, encara que representen el mateix, si es guarden en DB4O es tractaran com a objectes diferents, encara que hi haja una coincid\u00e8ncia amb tots i cadasc\u00fan dels seus valors. \u00c9s per aix\u00f2 que es recomana utilitzar nom\u00e9s una \u00fanica inst\u00e0ncia per cada objecte que l\u2019aplicaci\u00f3 necessite. Si una inst\u00e0ncia ja est\u00e0 guardada, caldr\u00e0 recuperar-la de la Base de Dades, ja que les successives recuperacions d\u2019un mateix objecte retornen sempre la mateixa refer\u00e8ncia en mem\u00f2ria. Si la inst\u00e0ncia no estiguera guardada, caldria instanciar-la una \u00fanica vegada fent servir qualsevol forma d\u2019instanciaci\u00f3 suportada pel llenguatge (utilitzant, per exemple, una sent\u00e8ncia new seguida del constructor). A banda de la instanciaci\u00f3 d\u2019objectes i del concepte d\u2019identitat utilitzat, DB4O afegeix un nou concepte que caldr\u00e0 tenir en compte a l\u2019hora d\u2019implementar aplicacions que la utilitzen. Es tracta del concepte d\u2019activaci\u00f3. Per tal d\u2019evitar un temps de proc\u00e9s i consum de mem\u00f2ria excessius a l\u2019hora de treballar amb estructures de dades molt complexes i ramificades, DB4O ofereix diverses formes de recuperar un objecte sense haver d\u2019instanciar tots i cadascun dels seus objectes interns. DB4O ofereix la possibilitat d\u2019indicar la profunditat a la qual es vol fer la recuperaci\u00f3. Per defecte, la profunditat utilitzada \u00e9s 5, per\u00f2 podem canviar-ho a voluntat. Una vegada instanciat un objecte podem canviar la seua profunditat d\u2019activaci\u00f3 de forma din\u00e0mica en qualsevol moment, de manera que disposem d\u2019un mecanisme per accedir a tots els objectes que l\u2019aplicaci\u00f3 requereix en el moment que siga necessari sense haver de malgastar recursos.","title":"1 - Bases de Dades Orientades a Objectes"},{"location":"3__bases_de_dades_orientades_a_objectes/#11-installacio-de-db4o","text":"DB4O va ser desenvolupat per la companyia db4objects, Inc . En 2008 va ser adquirida per l'empresa Versant , que va continuar desenvolupant-lo com a Open Source. En 2012, Versant va ser adquirida per la companyia Actian , que ja no ha continuat desenvolupant-lo com a Open Source, optant per un altre producte de pagament. A pesar de l'anterior, utilitzarem DB4O, encara que siga una versi\u00f3 creada ja fa un temps. Per una banda ens far\u00e0 falta el driver, el controlador. El podem obtenir des de la p\u00e0gina que Actian mant\u00e9 per a les versions anteriors: http://supportservices.actian.com/versant/default.html Dins d'aquesta p\u00e0gina veurem un apartat de db4o (on diu que ja no s'actualitzar\u00e0), per\u00f2 igual podrem baixar-nos el packet per a Java: https://www.dropbox.com/s/s6farl3dqez7e1r/db4o-8.0.276.16149-java.zip?dl=0 Ens descarreguem aquest zip, del qual realment l'unic que ens interessa \u00e9s el seg\u00fcent fitxer, situat en el directori libs db4o-8.0.249.16098-core-java5.jar Aquest \u00e9s el driver que incorporarem al nostre projecte. Per una altra banda, buscarem un entorn dins de IntelliJ per a poder veure les dades d'una Base de Dades de DB4O. \u00c9s tan senzill com anar a la \u00e0gina de plugins ( File - > Settings -> Plugins ) i en la pestanya Marketplace buscar db4o Una vegada instal\u00b7lat conv\u00e9 una reinicialitzaci\u00f3 de IntelliJ, i trobarem una entrada en View - > Tool windows -> db4o , que far\u00e0 que s'\u00f2biga una finestra a la part de baix per a poder inspeccionar els objectes d'una Base de Dades db4o, com veurem un poc m\u00e9s avant","title":"1.1 - Instal\u00b7laci\u00f3 de DB4O"},{"location":"3__bases_de_dades_orientades_a_objectes/#12-funcionalitat-basica","text":"Treballarem sobre un exemple anterior, el dels empleats, per\u00f2 incorporant m\u00e9s dades, com els tel\u00e8fons, els correus electr\u00f2nics, etc, per veure que podem guardar una classe un poc m\u00e9s complicada en la BD Orientada a Objectes. En un projecte nou, anomenat Tema6 , anem a incorporar el driver de DB4O db4o-8.0.249.16098-all-java5.jar Per organitzar-lo millor creem un paquet anomenat classesEmpleat , que ens servir\u00e0 per a fer tots els exemples. Ens crearem la classe Empleat , i les classes Adreca i Telefon que utilitzar\u00e0 aquella. Constru\u00efm les classes de la manera m\u00e9s c\u00f2moda. Aix\u00f2 s\u00ed, a Empleat li afegirem dos constructors per a fer m\u00e9s c\u00f2moda la introducci\u00f3 d'Empleats amb poques dades, ja veurem per qu\u00e8. class Adreca (var carrer: String?, var codipostal: String?, var poblacio: String?) class Telefon( var mobil : Boolean , var numero: String) Ara ja va Empleat : class Empleat ( var nif: String? , var nom: String? , var departament: Int? , var edat: Int? = 0 , var sou: Double? = 0.0 , var foto: Array<Byte>? , var curriculum: Array<Char>? , var adreca: Adreca? , var correus_e: Array<String>? , var telefons : Array<Telefon>? ) { constructor() : this(null,null,null,null,null,null,null,null,null,null) constructor(nif: String) : this(nif,null,null,null,null,null,null,null,null,null) } Com coment\u00e0vem anteriorment, hi ha una versi\u00f3 servidor, per\u00f2 que nosaltres ens conformarem amb la versi\u00f3 integrada ( embedded ). En el cas de la versi\u00f3 servidor utilitzar\u00edem la classe Db4o per a fer la connexi\u00f3. Com que nosaltres farem servir la versi\u00f3 integrada, utilitzarem la classe Db4oEmbedded . Connexi\u00f3 \u00c9s tan senzill com cridar des de la classe Db4oEmbedded el m\u00e8tode est\u00e0tic openFile() passant-li com a par\u00e0metre el nom del fitxer. A partir d\u2019aquest moment, es mantindr\u00e0 oberta una transacci\u00f3 que continuar\u00e0 activa fins que tanquem amb el m\u00e8tode close() . val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") Inserci\u00f3 Per a guardar un objecte utilitzem el m\u00e8tode store(objecte) Provem a introduir un empleat. Guardeu el seg\u00fcent programa en Exemple1_InserirEmpleat.kt . Guardeu-lo en el paquet exemples import com.db4o.Db4oEmbedded import classesEmpleat.Empleat import classesEmpleat.Adreca import classesEmpleat.Telefon fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") var e = Empleat(\"11111111a\",\"Albert\",10,45,1000.0,null,null,null,null,null) // les dades m\u00e9s complicades les introdu\u00efm de forma especial e.adreca = Adreca(\"C/ Major, 7\", \"12001\", \"Castell\u00f3\") e.correus_e = arrayOf(\"alu11111111a@ieselcaminas.org\") e.telefons = arrayOf(Telefon(true, \"666777888\"), Telefon(false, \"964112233\")) bd.store(e); bd.close(); } S\u00ed que ha guardat l'objecte. Mirem-lo des de la finestra de DB4O: On hem obert la BD apretant el bot\u00f3 Open (de vegades no mostra les dades dient que This view is not available until indexes are built . Ho podem solucionar reiniciant IntelliJ i aix\u00ed obligant a reconstruir els \u00edndex). I hem apretat el bot\u00f3 Get Objects tenint seleccionada la classe Empleats . En finalitzar d'observar les dades des de la finestra DB4O \u00e9s convenient tancar la connexi\u00f3 . Si no la tanquem, quan anem a executar qualsevol programa que accedisca, ens donar\u00e0 error, avisant que la Base de Dades est\u00e0 bloquejada ( com.db4o.ext.DatabaseFileLockedException ). Per tant, haurem de tenir especial atenci\u00f3 a tancar la connexi\u00f3 a la Base de Dades. Podria passar que ens donara un error el programa, i la connexi\u00f3 s'haja quedat oberta. Segurament el m\u00e9s oport\u00fa ser\u00e0 intentar tancar el programa, o tancar IntelliJ, i d'aquesta manera desbloquejarem la Base de Dades. El m\u00e8tode commit obliga a guardar les dades cap al contenidor i activa de nou una transacci\u00f3 per a les properes operacions, per tant \u00e9s convenient anar utilitzant-lo despr\u00e9s d'una s\u00e8rie d'actualitzacions. Anem a posar algunes dades m\u00e9s, per a tenir un poc m\u00e9s de joc. Concretament seran dues empleades m\u00e9s. Copieu el seg\u00fcent codi al fitxer Exemple1_1_InserirMesEmpleats.kt import classesEmpleat.Adreca import classesEmpleat.Empleat import classesEmpleat.Telefon import com.db4o.Db4oEmbedded fun main() { val bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val e = Empleat(\"22222222b\", \"Berta\", 10, 35, 1700.0, null, null, null, null, null) val f = Empleat(\"33333333c\", \"Cl\u00e0udia\", 20, 37, 1500.0, null, null, null, null, null) //les dades m\u00e9s complicades les introdu\u00efm de forma especial e.adreca = Adreca (\"C/ Enmig, 7\", \"12001\", \"Castell\u00f3\") val corr = arrayOf( \"alu22222222b@ieselcaminas.org\", \"berta@gmail.com\" ) e.correus_e = corr val tels = arrayOf(Telefon(true,\"666555444\"), Telefon(false,\"964223344\")) e.telefons = tels f.adreca = Adreca (\"C/ de Dalt, 7\", null, \"Borriana\") val corr2 = arrayOf(\"alu33333333c@ieselcaminas.org\") f.correus_e = corr2 bd.store(e) bd.store(f) bd.close() } Consulta b\u00e0sica En la seg\u00fcent pregunta, veurem les maneres de fer una consulta, per\u00f2 ara anem a veure la forma m\u00e9s senzilla, que \u00e9s la realitzada a trav\u00e9s del m\u00e8tode anomenat queryByExample . Aquest m\u00e8tode rep per par\u00e0metre un objecte del tipus a cercar, que far\u00e0 d\u2019exemple o patr\u00f3 per trobar totes aquelles inst\u00e0ncies emmagatzemades coincidents amb les dades del patr\u00f3. El patr\u00f3 que es passe per par\u00e0metre no haur\u00e0 de tenir totes les dades complimentades, sin\u00f3 nom\u00e9s aquelles de les quals se\u2019n desitge la coincid\u00e8ncia. Aix\u00ed, per exemple, si passem un objecte d'Empleat amb un \u00fanic atribut introdu\u00eft (el nif ), queryByExample retornar\u00e0 totes aquelles inst\u00e0ncies que tinguen per nif el valor entrat. Per aquesta ra\u00f3 vol\u00edem un constructor amb nom\u00e9s el nif, per a poder buscar l'empleat amb aquest nif amb queryByExample() . El retorn es fa en un objecte de tipus ObjectSet , una classe que implementa la interf\u00edcie List de Java i tamb\u00e9 la interf\u00edcie Iterable , de manera que siga possible rec\u00f3rrer el contingut utilitzant els m\u00e8todes next i hasNext . Tamb\u00e9 podem utilitzar el bucle for (el del foreach ). En el seg\u00fcent exemple es veu com una vegada obtingut l'objecte, es pot accedir molt f\u00e0cilment a tota la informaci\u00f3. Copieu-lo al fitxer Kotlin Exemple2_ConsultaUnEmpleat.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() as Empleat println( \"Nif: \" + e.nif + \". Nom: \" + e.nom + \". Poblaci\u00f3: \" + e.adreca?.poblacio ) if (e.correus_e != null) print(\"Primer correu: \" + e.correus_e?.get(0) + \".\") if (e.telefons != null) print(\"Primer tel\u00e8fon: \" + e.telefons!![0].numero + \".\") println() } bd.close(); } Observeu com no hem utilitzat un bucle per a rec\u00f3rrer la llista, sin\u00f3 un if. Aix\u00f2 \u00e9s perqu\u00e8 en aquest cas concret sabem a priori que en cas de trobar alguna inst\u00e0ncia, nom\u00e9s ser\u00e0 una. Aquest seria el resultat: Nif: 11111111a. Nom: Albert. Poblaci\u00f3: Castell\u00f3 Primer correu: alu11111111a@ieselcaminas.org. Primer tel\u00e8fon: 666777888. Esborrat Per a poder fer una actualitzaci\u00f3 o esborrat d'algun objecte de la Base de Dades, aquest s'ha de correspondre amb algun objecte del programa Java o Kotlin, \u00e9s a dir, l'objecte ha de ser persistent. Aquesta correspond\u00e8ncia pot ser perqu\u00e8 un objecte nou l'hem guardat amb store() (i continua \"viu\"), o perqu\u00e8 l'hem llegit de la BD (millor dit, hem llegit una llista i despr\u00e9s hem fet l'assignaci\u00f3 a un objecte). L\u2019eliminaci\u00f3 dels objectes s\u2019aconsegueix amb el m\u00e8tode delete . Per defecte, DB4O elimina nom\u00e9s l'objecte que es passa com a par\u00e0metre, per\u00f2 no els objectes que aquest puga contenir. Si un objecte cont\u00e9 un altre objecte, com succeeix amb les inst\u00e0ncies Empleat i Adreca i Telefon , aix\u00f2 pot convertir-se en un gran problema, ja que s\u00f3n objectes que normalment no es manipularan per separat i, en cas que no s\u2019esborren amb el seu propietari, continuaran indefinidament en la Base de Dades. Per evitar-lo haur\u00edem de configurar per a que esborre en cascada . Mirem un exemple en el qual esborrem un empleat. En el comentari teniu el moment en que encara no es corresponen, i per tant no es pot esborrar. Recordeu que despr\u00e9s d'aquest exemple, quedar\u00e0 inconsistent la informaci\u00f3. Si no voleu fer-lo, poder saltar-vos-el. De tota manera, si el feu i queda inconsistent la informaci\u00f3 sempre podem esborrar la Base de Dades i tornar a executar Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt . Si teniu ganes de fer-lo, guardeu-lo en el fitxer Exemple3_EsborratDefectuos.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val patro = Empleat(\"22222222b\") // Si pos\u00e0rem ac\u00ed db.delete(patro) no tindr\u00eda efecte, perqu\u00e8 e no es // correspon amb cap inst\u00e0ncia de la BD val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() bd.delete(e) } bd.close() } Com que no hem esborrat en cascada , si despr\u00e9s mirem des de la perspectiva OME, comprovarem que encara existeixen els objectes adre\u00e7a i tel\u00e8fon, i que ara no correspondran a cap empleat. Haur\u00edem d'aprofitar el moment per a esborrar des de la perspectiva OME les inst\u00e0ncies de Adreca i Telefon que corresponien a l'empleat que hem esborrat, per deixar-lo consistent. En les seg\u00fcents imatges es mostra aquest fet: Ja no existeix l'objete Empleat corresponent a Berta, per\u00f2: encara existeix la seua adre\u00e7a (C/Enmig, 7 de Castell\u00f3) i els seua tel\u00e8fons (666555444 i 964223344) Per a poder esborrar en cascada , en el moment d\u2019obrir el fitxer contenidor haurem d'especificar-lo posant-li una configuraci\u00f3 com veurem a continuaci\u00f3. No \u00e9s possible modificar la configuraci\u00f3 de forma din\u00e0mica. A m\u00e9s, malauradament, la configuraci\u00f3 no es guarda amb el fitxer contenidor, sin\u00f3 que cada vegada que obrim, haurem d'especificar-li la configuraci\u00f3 desitjada. En aquesta configuraci\u00f3 li direm que la classe Empleat esborra en cascada, \u00e9s a dir, que quan esborrem un objecte, els objectes \"subordinats\" (de les classes Adreca i Telefon ) tamb\u00e9 s'esborraran. Copieu el seg\u00faent codi en un fitxer anomenat Exemple4_EsborratCorrecte.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { val conf = Db4oEmbedded.newConfiguration() conf.common().objectClass(\"classesEmpleat.Empleat\").cascadeOnDelete(true) val bd = Db4oEmbedded.openFile(conf,\"Empleats.db4o\") val patro = Empleat(\"33333333c\") // Si pos\u00e0rem ac\u00ed db.delete(patro) no tindr\u00eda efecte, perqu\u00e8 e no es // correspon amb cap inst\u00e0ncia de la BD val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { val e = llista.next() bd.delete(e) } bd.close() } En les seg\u00fcents imatges es mostra com ara s\u00ed que ha esborrat en cascada: Hem esborrat a Cl\u00e0udia I tamb\u00e9 ha desaparegut la seua adre\u00e7a (C/ de Dalt de Borriana). Com que no tenia tel\u00e8fons, continuen els mateixos d'abans Modificaci\u00f3 Per a modificar un objecte de la Base de Dades primer haurem de tenir un objecte de Java que es corresponga amb ell (igual que en l'esborrat). Despr\u00e9s de modificar-lo, nom\u00e9s l'haurem de guardar amb store() . Hem de parar atenci\u00f3 a que si el que volem modificar \u00e9s d'una subclasse, haurem de modificar en cascada , sin\u00f3 no tindr\u00e0 efecte. Ho farem indicant cascadeOnUpdate(true) a la configuraci\u00f3 amb qu\u00e8 obrirem el fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple5_ModificarCascada.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.config.EmbeddedConfiguration import classesEmpleat.Adreca import classesEmpleat.Empleat fun main() { val conf = Db4oEmbedded.newConfiguration() conf.common().objectClass(\"classesEmpleat.Empleat\").cascadeOnUpdate(true) val bd = Db4oEmbedded.openFile(conf, \"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { var e = llista.next() if (e.sou != null) { e.sou = e.sou.toString().toDouble() + 200.0 } val adr = e.adreca adr?.carrer = \"Pl. Rei en Jaume, 15\" adr?.codipostal = \"12002\" e.adreca = adr bd.store(e) } bd.close() } En la imatge es veu que en fer l'actualitzaci\u00f3 en cascada s\u00ed que s'han guardat els canvis, i la primera adre\u00e7a (que \u00e9s la corresponent a Albert) s'ha modificat. La restricci\u00f3 que hem comentat abans de que hem de tenir un objecte de Java que es corresponga amb ell (que ocupa els casos d'esborrat i modificaci\u00f3), l'hem de tenir molt present. I hem d'anar amb compte, perqu\u00e8 quan es tanca la BD es perd tota correspond\u00e8ncia. El seg\u00fcent exemple \u00e9s id\u00e8ntic a l'anterior, per\u00f2 es tanca i es torna a obrir la BD despr\u00e9s d'haver assignat a e l'objecte, i abans de guardar-lo; per tant L'OBJECTE EST\u00c0 SEPARAT (ja no est\u00e0 associat a un objecte de la Base de Dades). En principi el que voldr\u00edem \u00e9s modificar les dades de l'empleat existent, per\u00f2 en realitat hem introdu\u00eft un nou empleat (amb el mateix nif, nom, ...), i per tant molt perill\u00f3s perqu\u00e8 estem duplicant la informaci\u00f3. Observeu que, com que nom\u00e9s es vol modificar el sou, no cal actualitzar en cascada. Si voleu provar l'exemple, gaurdeu el seg\u00fcent codi en el fitxer Kotlin Exemple6_Modificaci\u00f3Incorrecta.kt . I recordeu que la Base de Dades haur\u00e0 quedat malament, i per tant el millor seia esborrar-la i tornar a executar els exemples Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Empleat fun main() { var bd = Db4oEmbedded.openFile (\"Empleats.db4o\") val patro = Empleat(\"11111111a\") val llista = bd.queryByExample<Empleat>(patro) if (llista.hasNext()) { var e = llista.next() if (e.sou != null) { e.sou = e.sou.toString().toDouble() + 200.0 } bd.close() // Tanquem i tornem a obrir la BD, per veure que hem // perdut la correspond\u00e8ncia de e amb l'objecte de la BD bd = Db4oEmbedded.openFile(\"Empleats.db4o\") bd.store(e) } bd.close() } Ara el contingut de la Base de Dades \u00e9s aquest: On es veu que hem creat un nou objecte, en compte de modificar el que ja existia. I el mateix amb l'adre\u00e7a i els tel\u00e8fons En cas que tanquem la BD i vulguem modificar o esborrar un objecte haurem de tornar a connectar amb ell. I en el cas de la inserci\u00f3, abans d'inserir, podr\u00edem comprovar que no existeix (per exemple que no existeix cap empleat amb aquest nif).","title":"1.2 - Funcionalitat b\u00e0sica"},{"location":"3__bases_de_dades_orientades_a_objectes/#13-consultes","text":"DB4O disposa de tres formes de realitzar consultes. Totes elles s\u00f3n de tipus NoSQL. Nota Si hav\u00edeu fet tots els exemples anteriors, potser siga millor esborrar Empleats.db4o i tornar a executar Exemple1_InserirEmpleat.kt i Exemple1_1_InserirMesEmpleats.kt per a crear-les de nou. M\u00e8tode Query By Example La primera forma ja s\u2019ha comentat, \u00e9s la que s\u2019anomena consulta basada en un exemple o \u201c query by example \u201d. Consisteix, com ja hem vist, en trobar totes les inst\u00e0ncies guardades que coincidesquen amb els valors no nuls i diferents de zero (en cas que siguen num\u00e8rics) d\u2019un patr\u00f3 o exemple passat per par\u00e0metre. Si, per exemple, volem traure els empleats del departament 10 que s\u00f3n de Castell\u00f3, n\u2019hi hauria prou amb crear el patr\u00f3 que posem a continuaci\u00f3. Copieu el seg\u00fcent codi al fitxer Exemple11_Consulta_QueryByExample.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import classesEmpleat.Adreca import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded. openFile(\"Empleats.db4o\") val patro = Empleat() patro.departament = 10 patro.adreca = Adreca (null, null, \"Castell\u00f3\") val llista = bd.queryByExample<Empleat>(patro) for (e in llista) { System.out.println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \". Departament: \" + e.departament + \". Poblaci\u00f3: \" + e.adreca?.poblacio ) } bd.close() } cosa que donar\u00e0 com a resultat el seg\u00fcent, que es pot comprovar que s\u00f3n del departament 10 i de Castell\u00f3: Nif: 11111111a. Nom: Albert. Departament: 10. Poblaci\u00f3: Castell\u00f3 Nif: 22222222b. Nom: Berta. Departament: 10. Poblaci\u00f3: Castell\u00f3 Seguint aquest raonament, per obtenir tots els empleats de l\u2019aplicaci\u00f3 caldr\u00e0 passar un patr\u00f3 empleat sense valors ( bd.queryByExample(Empleat() ) ), i si el que desitgem \u00e9s obtenir tots els objectes emmagatzemats a la base de dades, el que haurem de passar com a par\u00e0metre \u00e9s un valor null ( bd.queryByExample(null) ). Com podeu veure, resulta un sistema molt simple. Ara b\u00e9, tamb\u00e9 t\u00e9 moltes limitacions en consultes m\u00e9s complexes, i fins i tot poden resultar impossibles. Posem alguns exemples en els quals no funciona aquest tipus de consulta: \u00c9s impossible trobar tots els empleats que no tinguen algun camp assignat encara (\u00e9s a dir, null) a causa del mecanisme utilitzat: nom\u00e9s s\u2019avaluen els camps no nulls. Tampoc podr\u00edem trobar aquells empleats que cobren m\u00e9s de 1300\u20ac . En aquest tipus de consulta nom\u00e9s podem buscar igualtats. Com es basa en la coincid\u00e8ncia, no podrem fer consultes que puguen agafar un de dos o m\u00e9s valors determinats. Per exemple, agafar els empleats que s\u00f3n de Castell\u00f3 o Borriana. M\u00e8tode Native Queries DB4O disposa d\u2019un sistema molt m\u00e9s potent anomenat Native Queries . \u00c9s f\u00e0cil deduir que es tracta d\u2019un sistema vinculat directament al mateix llenguatge de programaci\u00f3. De fet, es tracta de construir un procediment en el qual s'avaluen els objectes i es decideix quins objectes acompleixen la condici\u00f3 i quins no. Per a fer la consulta haurem de crear una classe que implemente una interf\u00edcie anomenada Predicate . Aquesta interf\u00edcie consta d'un \u00fanic m\u00e8tode declarat anomenat match . La classe nostra que implementar\u00e0 Predicate haur\u00e0 de sobreescriure el m\u00e8tode match(), i en aquest m\u00e8tode podrem posar una s\u00e8rie de sent\u00e8ncies Kotlin i dir si cada objecte de la Base de Dades acompleix o no la condici\u00f3 tornant respectivament true o false. En el seg\u00fcent exemple creem una classe anomenada EmpleatsPerPoblacio (que implementa Predicate ), a la qual se li pot passar en el constructor un vector de cadenes de car\u00e0cters amb els noms de les poblacions de les quals volem els empleats. En la implementaci\u00f3 del m\u00e8tode match tornarem cert si l'empleat \u00e9s d'alguna de les poblacions, i fals en cas contrari. Com que utilitzem el mateix llenguatge de programaci\u00f3, la pot\u00e8ncia \u00e9s molt elevada. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple12_Consula_NativeQuery_1.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Predicate import classesEmpleat.Empleat class EmpleatsPerPoblacio(pobles: Array<String>) : Predicate<Empleat>() { val poblacions = pobles override fun match(emp: Empleat): Boolean { return (emp.adreca?.poblacio in poblacions) } } fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val pobl = arrayOf(\"Castell\u00f3\", \"Borriana\") val llista = bd.query(EmpleatsPerPoblacio(pobl)) for (e in llista) { println(e.nom + \" (\" + e.adreca?.poblacio + \")\") } bd.close() } Observeu que una vegada definida la classe, podem fer-la servir en una Query per realitzar una consulta espec\u00edfica. En l'exemple, s'obtenen tots els empleats que s\u00f3n de Castell\u00f3 o de Borriana. En variar la llista de poblacions obtindrem uns objectes empleat o uns altres. En el m\u00e8tode match, que \u00e9s qui diu si un element Empleat compleix la condici\u00f3, es comprova si la poblaci\u00f3 de l'empleat (que est\u00e0 dins d'adre\u00e7a, i per tant s'accedeix amb emp.adreca?.poblacio ) est\u00e0 dins de l'array de poblacions. Com que es tracta d\u2019una interf\u00edcie amb un \u00fanic m\u00e8tode a implementar, no caldr\u00e0 que implementem sempre noves classes per a cada consulta diferent, sin\u00f3 que podem fer servir classes anidades an\u00f2nimes (anonymous nested class), per a fer-lo molt m\u00e9s curt, definint la classe en el oment d'utilitzar-la. Mirem-ho en un altre exemple, en el qual es buscaran els empleats que tinguen el sou entre dos valors determinats. Constru\u00efm la classe Predicate en el mateix lloc on s'utilitza, en el query() , i no abulta molt perqu\u00e8 nom\u00e9s t\u00e9 el m\u00e8tode match() . En el m\u00e8tode match() \u00e9s on es comprova la condici\u00f3. Copieu el seg\u00fcent codi en el fitxer Exemple13_NativeQuery_2.kt : import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Predicate import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val max = 1500.0 val min = 1000.0 val llista = bd.query(object: Predicate<Empleat>() { override fun match(emp: Empleat): Boolean { if (emp.sou.toString().toDouble() <= max && emp.sou.toString().toDouble() >= min) return true else return false } }) for (e in llista) { System.out.println(e.nom + \" (\" + e.sou + \")\") } bd.close() } En tractar-se d\u2019una interf\u00edcie amb un \u00fanic m\u00e8tode a implementar, no caldr\u00e0 que implementem sempre noves classes per a cada consulta diferent, sin\u00f3 que podem fer servir classes imbricades an\u00f2nimes ( anonimous nested class ). Recordeu que les classes imbricades poden treballar directament amb tots els atributs (tinguin l\u2019\u00e0mbit que tinguin) de la classe que les contingui i que les classes an\u00f2nimes es defineixen a l\u2019interior d\u2019un m\u00e8tode qualsevol. M\u00e8tode SODA Existeix encara una altra forma de definir consultes. DB4O l\u2019anomena SODA ( Simple Object Database Access ), i es pot considerar com la forma d\u2019accedir a l\u2019estructura interna de la base de dades a baix nivell per tal de seleccionar els nodes de dades que complesquen uns determinats requisits i que acabaran determinant el resultat de la consulta. De fet, segons indiquen els autors, \u00e9s la forma de consulta m\u00e9s r\u00e0pida de les tres. La idea fonamental de SODA \u00e9s construir les consultes com un recorregut d\u2019una xarxa de nodes enlla\u00e7ats. Els nodes de la consulta s\u2019estructuren de forma semblant a les classes emmagatzemades a la base de dades, de manera que el cam\u00ed seguit en avaluar la consulta, node a node, es repeteix en les inst\u00e0ncies emmagatzemades, la qual cosa permet accedir als valors per avaluar de forma r\u00e0pida. El cam\u00ed s\u2019especifica utilitzant el m\u00e8tode descend() per mitj\u00e0 del qual seleccionem la branca de l\u2019estructura de classes que vulguem fer refer\u00e8ncia. Per exemple, si ens trobem en el node de la classe Empleat i volgu\u00e9rem fer refer\u00e8ncia al nom de la poblaci\u00f3 que en l\u2019estructura de classes es troba a empleat.adreca.poblacio , haur\u00edem de fer node.descend(\"adreca\").descend(\"poblacio\") El resultat de la sent\u00e8ncia anterior \u00e9s un node focalitzat a l\u2019atribut poblaci\u00f3 continguda a l\u2019adre\u00e7a de l'empleat. Cada node pot estar afectat per una restricci\u00f3, per una ordenaci\u00f3 i/o per una operaci\u00f3 amb una altre node. Les restriccions permeten seleccionar o desestimar les inst\u00e0ncies que es vagen comprovant. Les ordenacions, com \u00e9s natural, forcen l\u2019ordre de les inst\u00e0ncies seleccionades d\u2019acord amb els valors de l\u2019atribut representat pel node afectat. Finalment, les operacions marquen quin ser\u00e0 el seg\u00fcent node a avaluar, el qual actuar\u00e0 tamb\u00e9 com a filtre dels objectes de la selecci\u00f3. Les restriccions es veuran afectades per una o m\u00e9s relacions que permetran modificar la comparaci\u00f3 i sentenciar en favor o en contra de la selecci\u00f3 d\u2019una inst\u00e0ncia. Per defecte, la relaci\u00f3 avaluada \u00e9s la d\u2019igualtat. Per exemple, si partim d\u2019un node que representa el NIF d\u2019un empleat, podem definir la relaci\u00f3 d\u2019igualtat seg\u00fcent: node.constrain(\"11111111a\") Mirem com quedaria el programa que selecciona \u00fanicament l'empleat amb el nif anterior. Guardeu el seg\u00fcent codi al fitxer Exemple14_QuerySoda_1.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query () //node arrel. var node = q.descend (\"nif\") //arribem a l'altura del nif, que \u00e9s on posem la restricci\u00f3 node.constrain(\"11111111a\") val llista = q.execute<Empleat>() for (e in llista){ println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \" (\" + e.sou + \")\") } bd.close() } En realitat intentar\u00e0 agafar en principi tots els objectes de la Base de Dades, i recordem que tenim objectes Empleat , Adreca i Telefon . Per\u00f2 observeu que no cal especificar que siga \u00fanicament objectes de la classe Empleat , perqu\u00e8 \u00e9s l'\u00fanica classe que t\u00e9 una propietat anomenada nif , per tant \u00fanicament selccionar\u00e0 empleats Per\u00f2 si la relaci\u00f3 ha de ser una comparaci\u00f3 de tipus major que , menor o igual que , ... , caldr\u00e0 especificar-les expressament. La manera ser\u00e0 especificant un m\u00e8tode de la restricci\u00f3. Les possibilitats seran: Major: greater() Si suposem que partim d\u2019un node focalitzat al sou d\u2019un empleat i volem la condici\u00f3 que el sou siga major estrictament que 1300. S\u2019indicaria d'aquesta manera: node.constrain(1300).greater() Menor: smaller() Si volem que el sou siga estrictament menor que 1500: node.constrain(1500).smaller() Major o igual, menor o igual: equal() (despr\u00e9s del greater o smaller) Si ara volem que el sou siga menor o igual que 1500: node.constrain(1300).smaller().equal() Que comence per: startsWith(boolean) Si partim d'un node focalitzat al nom de l'empleat i volem els que comencen per A : node.constrain(\"A\").startsWith(true) Si en el par\u00e0metre boole\u00e0 posem true, haur\u00e0 de coincidir exactament el principi. Si posem false, no distingir\u00e0 entre maj\u00fascules i min\u00fascules. Per a unir restriccions: or(restriccio) and(restriccio) . Per a negar not() Per exemple, si partim d\u2019un node focalitzat al nom de l'empleat, podem seleccionar tots els que comencen per A o per B , fent: var constr1 = node.constrain(\"A\").startsWith() val constr2 = node.constrain(\"B\").startsWith() constr1.or(constr2) Si posem m\u00e9s d'una restricci\u00f3 (m\u00e9s d'un constrain), s'hauran de complir totes, i per tant actua com un and A banda de les restriccions, si volem ordenar de forma ascendent o descendent, ho indicarem amb els m\u00e8tode orderAscending() o orderDescending() del node pel mig del qual volem ordenar . Mirem un parell d'exemples per veure com es posa tot en joc. Anem a construir la sent\u00e8ncia que permeta seleccionar tots els empleats amb un sou que oscil\u00b7le entre un rang de valors definits (estrictament major que 1000, i menor o igual que 1500, per exemple) ordenats de forma descendent per sou. Guardeu-lo al fitxer Exemple15_QuerySoda_2.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query() //node arrel. var node = q.descend(\"sou\") //arribem a l'altura del sou, que \u00e9s on posem la restricci\u00f3 node.constrain(1000).greater().and(node.constrain(1500).smaller().equal()) node.orderDescending() val llista = q.execute<Empleat>() for (e in llista) { println(\"Nif: \" + e.nif + \". Nom: \" + e.nom + \" (\" + e.sou + \")\") } bd.close() } I ara els empleats del departament 10 que s\u00f3n de Castell\u00f3. Podem utilitzar el mateix objecte node per anar afegint restriccions, per\u00f2 haurem de cuidar de localitzar-lo al lloc oport\u00fa. Guardeu-llo amb el nom Exemple16_QuerySoda_3.kt import com.db4o.Db4oEmbedded import com.db4o.ObjectContainer import com.db4o.ObjectSet import com.db4o.query.Query import classesEmpleat.Empleat fun main() { val bd = Db4oEmbedded.openFile(\"Empleats.db4o\") val q = bd.query() //node arrel. var node = q.descend(\"departament\") //arribem a l'altura del departament, que \u00e9s on posem la restricci\u00f3 node.constrain(10) node = q.descend(\"adreca\").descend(\"poblacio\") //i ara arribem a l'altura de la poblaci\u00f3 de l'adre\u00e7a node.constrain(\"Castell\u00f3\") val llista = q.execute<Empleat>() for (e in llista) { println(\"Nom: \" + e.nom + \". Poblaci\u00f3: \" + e.adreca?.poblacio + \". Departament: \" + e.departament) } bd.close() } Tot i que cal ens proporciona 3 maneres de fer les consultes, i al final aquestes poden ser potents, no \u00e9s capa\u00e7 de tenir tota l\u2019expressivitat d\u2019un llenguatge com OQL. No disposa de funcions d\u2019agregat (SUM, AVG, MAX, MIN, ...), ni es poden expressar relacions entre inst\u00e0ncies. \u00c9s l\u2019aplicaci\u00f3 la que haur\u00e0 de fer-se responsable que aix\u00f2 siga possible. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.3 - Consultes"},{"location":"exercicis/","text":"Exercicis Exercici 6.1 Crea un nou paquet anomenat exercicis en el projecte Tema6 . Incorpora en el projecte el driver per a DB4O , sino el tenies incorporat. Copia el paquet util.bd al projecte. Aquest paquet el vam fer en l'exercici T4Ex4 i inclou les classes Coordenades.kt , PuntGeo.kt i Ruta.kt . Tamb\u00e9 inclou la classe GestionarRutesBD.java , que ens permetia gestionar la BD Rutes.sqlite Copia tamb\u00e9 la BD Rutes.sqlite , creada en exercicis anteriors, per\u00f2 que l'\u00faltima actualitzaci\u00f3 \u00e9s del mateix exercici. Incorpora el driver de SQLite Hem de canviar la definici\u00f3 de les propietats de la classe Ruta , ja que ara hem de permetre valors nuls per a poder fer consultes pel m\u00e8tode queryByExample() . La manera m\u00e9s senzilla segurament ser\u00e0: class Ruta (var nom: String?, var desnivell: Int?, var desnivellAcumulat: Int?, var llistaDePunts: MutableList<PuntGeo> = mutableListOf<PuntGeo>()): Serializable D'aquesta manera, per a crar un objecte Ruta que estiga totalment buit, ho far\u00edem aix\u00ed: Ruta(null,null,null) Podria ser que aquest canvi en la definici\u00f3 de les propietat de Ruta provoque algun error en GestionarRutesBD . Si \u00e9s aix\u00ed corregeix-los A partir d'aci comen\u00e7a realment l'exercici, que consistir\u00e0 en passar les dades des de Rutes.sqlite fins la Base de Dades de DB4O Rutes.db4o . Crea't el programa Ex1_PassarRutaSqliteDB4O.kt . Has d'agafar totes les rutes de Rutes.sqlite i deixar-les en un ArrayList de Ruta amb el m\u00e8tode ja creat de GestionarRutesBD.java anomenat llistat() . Insereix totes les rutes en la BD Rutes.db4o . Tanca la connexi\u00f3. Crea't el programa Ex1_VisRutaDB4O.kt , que ha de connectar a la Base de Dades Rutes.db4o , ha de llegir totes les rutes (ves amb compte, perqu\u00e8 nom\u00e9s has de llegir rutes; s'han guardat m\u00e9s objectes: punts i coordenades) i ha de traure per pantalla el nom de la ruta i el n\u00famero de punts. Exercici 6.2 En el mateix projecte i paquet anem a fer una aplicaci\u00f3 amb interf\u00edcie gr\u00e0fica atancant a DB4O. El programa mostrar\u00e0 una ruta, i hi haur\u00e0 tamb\u00e9 uns botons per anar a la primera, anterior, seg\u00fcent i \u00faltima ruta. Hi ha tamb\u00e9 el bot\u00f3 de Tancar, que tancar\u00e0 la connexi\u00f3 amb la Base de Dades i eixir\u00e0 del programa. Per a omplir el JTable amb els punts, teniu un m\u00e8tode que ho fa autom\u00e0ticament: plenarTaula() . Observeu quin \u00e9s el seu par\u00e0metre. De moment tindr\u00e0 aquest aspecte: en el qual, a banda de les etiquetes ( JLabel ) i quadres de text ( JTextField ) tenim una taula ( JTable ) on col\u00b7locarem tots els punts de la ruta (nom, latitud i longitud). Tots els controls s\u00f3n no editables, per a no poder introduir cap informaci\u00f3. Aquest seria l'esquelet del programa. Copieu-lo en un fitxer Kotlin anomenat Ex2_VisRutes_DB4O.kt , i poseu les sent\u00e8ncies necess\u00e0ries despr\u00e9s dels comentaris: import java.awt.EventQueue import java.awt.GridLayout import java.awt.FlowLayout import javax.swing.JFrame import javax.swing.JPanel import javax.swing.BoxLayout import javax.swing.JComboBox import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JTable import javax.swing.JScrollPane import util.bd.Ruta import util.bd.PuntGeo import com.db4o.Db4oEmbedded class FinestraComplet : JFrame() { var llista = arrayListOf<Ruta>() var numActual = 0 // Declaraci\u00f3 de la Base de Dades val qNom = JTextField(15) val qDesn = JTextField(5) val qDesnAcum = JTextField(5) val punts = JTable(1, 3) val primer = JButton(\" << \") val anterior = JButton(\" < \") val seguent = JButton(\" > \") val ultim = JButton(\" >> \") val tancar = JButton(\"Tancar\") init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JDBC: Visualitzar Rutes Complet\") setLayout(GridLayout(0, 1)) val p_prin = JPanel() p_prin.setLayout(BoxLayout(p_prin, BoxLayout.Y_AXIS)) val panell1 = JPanel(GridLayout(0, 2)) panell1.add(JLabel(\"Ruta:\")) qNom.setEditable(false) panell1.add(qNom) panell1.add(JLabel(\"Desnivell:\")) qDesn.setEditable(false) panell1.add(qDesn) panell1.add(JLabel(\"Desnivell acumulat:\")) qDesnAcum.setEditable(false) panell1.add(qDesnAcum) panell1.add(JLabel(\"Punts:\")) val panell2 = JPanel(GridLayout(0, 1)) punts.setEnabled(false) val scroll = JScrollPane(punts) panell2.add(scroll, null) val panell5 = JPanel(FlowLayout()) panell5.add(primer) panell5.add(anterior) panell5.add(seguent) panell5.add(ultim) val panell6 = JPanel(FlowLayout()) panell6.add(tancar) add(p_prin) p_prin.add(panell1) p_prin.add(panell2) p_prin.add(panell5) p_prin.add(panell6) pack() primer.addActionListener { // instruccions per a situar-se en la primera ruta, i visualitzar-la } anterior.addActionListener { // instruccions per a situar-se en la ruta anterior, i visualitzar-la } seguent.addActionListener { // instruccions per a situar-se en la ruta seg\u00fcent, i visualitzar-la } ultim.addActionListener { // instruccions per a situar-se en l'\u00faltim ruta, i visualitzar-la } tancar.addActionListener { // instruccions per a tancar la BD i el programa } inicialitzar() VisRuta() } fun plenarTaula(ll_punts: MutableList<PuntGeo>) { var ll = Array(ll_punts.size) { arrayOfNulls<String>(3) } for (i in 0 until ll_punts.size) { ll[i][0] = ll_punts.get(i).nom ll[i][1] = ll_punts.get(i).coord.latitud.toString() ll[i][2] = ll_punts.get(i).coord.longitud.toString() } val caps = arrayOf(\"Nom punt\", \"Latitud\", \"Longitud\") punts.setModel(javax.swing.table.DefaultTableModel(ll, caps)) } fun inicialitzar() { // instruccions per a inicialitzar llista i numActual } fun VisRuta() { // instruccions per a visualitzar la ruta actual (l'\u00edndex el tenim en numActual ActivarBotons() } fun ActivarBotons() { // instruccions per a activar o desactivar els botons de moviment ( setEnabled(Boolean) ) } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraComplet().isVisible = true } } Exercici 6.3 (voluntari) Modificar la classe anterior per a incorporar tamb\u00e9 la dist\u00e0ncia total de la ruta . Per a poder calcular-la ens ajudarem de la seg\u00fcent funci\u00f3 que calcula la dist\u00e0ncia en quil\u00f2metres entre dos punts, donant les coordenades (latitud i longitud) dels dos punts: Dist(lat1,long1,lat2,long2) . Observeu que per a calcular la dist\u00e0ncia de forma correcta hem de tenir en compte tots els punts (si nom\u00e9s tenim en compte el primer punt i l'\u00faltim, la dist\u00e0ncia d'una ruta circular seria 0). Podeu incorporar-la a la classe on esteu fent l'exercici ( Ex2_VisRutes_DB4O.kt ). fun Dist(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double { val R = 6378.137 // Radi de la Tierra en km val dLat = rad(lat2 - lat1) val dLong = rad(lon2 - lon1) val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(rad(lat1)) * Math.cos(rad(lat2)) * Math.sin(dLong / 2) * Math.sin(dLong / 2) val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) val d = R * c return Math.round(d*100.0)/100.0 } fun rad(x: Double): Double { return x * Math.PI / 180 } Aquest seria un exemple: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Exercicis"},{"location":"exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"exercicis/#exercici-61","text":"Crea un nou paquet anomenat exercicis en el projecte Tema6 . Incorpora en el projecte el driver per a DB4O , sino el tenies incorporat. Copia el paquet util.bd al projecte. Aquest paquet el vam fer en l'exercici T4Ex4 i inclou les classes Coordenades.kt , PuntGeo.kt i Ruta.kt . Tamb\u00e9 inclou la classe GestionarRutesBD.java , que ens permetia gestionar la BD Rutes.sqlite Copia tamb\u00e9 la BD Rutes.sqlite , creada en exercicis anteriors, per\u00f2 que l'\u00faltima actualitzaci\u00f3 \u00e9s del mateix exercici. Incorpora el driver de SQLite Hem de canviar la definici\u00f3 de les propietats de la classe Ruta , ja que ara hem de permetre valors nuls per a poder fer consultes pel m\u00e8tode queryByExample() . La manera m\u00e9s senzilla segurament ser\u00e0: class Ruta (var nom: String?, var desnivell: Int?, var desnivellAcumulat: Int?, var llistaDePunts: MutableList<PuntGeo> = mutableListOf<PuntGeo>()): Serializable D'aquesta manera, per a crar un objecte Ruta que estiga totalment buit, ho far\u00edem aix\u00ed: Ruta(null,null,null) Podria ser que aquest canvi en la definici\u00f3 de les propietat de Ruta provoque algun error en GestionarRutesBD . Si \u00e9s aix\u00ed corregeix-los A partir d'aci comen\u00e7a realment l'exercici, que consistir\u00e0 en passar les dades des de Rutes.sqlite fins la Base de Dades de DB4O Rutes.db4o . Crea't el programa Ex1_PassarRutaSqliteDB4O.kt . Has d'agafar totes les rutes de Rutes.sqlite i deixar-les en un ArrayList de Ruta amb el m\u00e8tode ja creat de GestionarRutesBD.java anomenat llistat() . Insereix totes les rutes en la BD Rutes.db4o . Tanca la connexi\u00f3. Crea't el programa Ex1_VisRutaDB4O.kt , que ha de connectar a la Base de Dades Rutes.db4o , ha de llegir totes les rutes (ves amb compte, perqu\u00e8 nom\u00e9s has de llegir rutes; s'han guardat m\u00e9s objectes: punts i coordenades) i ha de traure per pantalla el nom de la ruta i el n\u00famero de punts.","title":"Exercici 6.1"},{"location":"exercicis/#exercici-62","text":"En el mateix projecte i paquet anem a fer una aplicaci\u00f3 amb interf\u00edcie gr\u00e0fica atancant a DB4O. El programa mostrar\u00e0 una ruta, i hi haur\u00e0 tamb\u00e9 uns botons per anar a la primera, anterior, seg\u00fcent i \u00faltima ruta. Hi ha tamb\u00e9 el bot\u00f3 de Tancar, que tancar\u00e0 la connexi\u00f3 amb la Base de Dades i eixir\u00e0 del programa. Per a omplir el JTable amb els punts, teniu un m\u00e8tode que ho fa autom\u00e0ticament: plenarTaula() . Observeu quin \u00e9s el seu par\u00e0metre. De moment tindr\u00e0 aquest aspecte: en el qual, a banda de les etiquetes ( JLabel ) i quadres de text ( JTextField ) tenim una taula ( JTable ) on col\u00b7locarem tots els punts de la ruta (nom, latitud i longitud). Tots els controls s\u00f3n no editables, per a no poder introduir cap informaci\u00f3. Aquest seria l'esquelet del programa. Copieu-lo en un fitxer Kotlin anomenat Ex2_VisRutes_DB4O.kt , i poseu les sent\u00e8ncies necess\u00e0ries despr\u00e9s dels comentaris: import java.awt.EventQueue import java.awt.GridLayout import java.awt.FlowLayout import javax.swing.JFrame import javax.swing.JPanel import javax.swing.BoxLayout import javax.swing.JComboBox import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JTable import javax.swing.JScrollPane import util.bd.Ruta import util.bd.PuntGeo import com.db4o.Db4oEmbedded class FinestraComplet : JFrame() { var llista = arrayListOf<Ruta>() var numActual = 0 // Declaraci\u00f3 de la Base de Dades val qNom = JTextField(15) val qDesn = JTextField(5) val qDesnAcum = JTextField(5) val punts = JTable(1, 3) val primer = JButton(\" << \") val anterior = JButton(\" < \") val seguent = JButton(\" > \") val ultim = JButton(\" >> \") val tancar = JButton(\"Tancar\") init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JDBC: Visualitzar Rutes Complet\") setLayout(GridLayout(0, 1)) val p_prin = JPanel() p_prin.setLayout(BoxLayout(p_prin, BoxLayout.Y_AXIS)) val panell1 = JPanel(GridLayout(0, 2)) panell1.add(JLabel(\"Ruta:\")) qNom.setEditable(false) panell1.add(qNom) panell1.add(JLabel(\"Desnivell:\")) qDesn.setEditable(false) panell1.add(qDesn) panell1.add(JLabel(\"Desnivell acumulat:\")) qDesnAcum.setEditable(false) panell1.add(qDesnAcum) panell1.add(JLabel(\"Punts:\")) val panell2 = JPanel(GridLayout(0, 1)) punts.setEnabled(false) val scroll = JScrollPane(punts) panell2.add(scroll, null) val panell5 = JPanel(FlowLayout()) panell5.add(primer) panell5.add(anterior) panell5.add(seguent) panell5.add(ultim) val panell6 = JPanel(FlowLayout()) panell6.add(tancar) add(p_prin) p_prin.add(panell1) p_prin.add(panell2) p_prin.add(panell5) p_prin.add(panell6) pack() primer.addActionListener { // instruccions per a situar-se en la primera ruta, i visualitzar-la } anterior.addActionListener { // instruccions per a situar-se en la ruta anterior, i visualitzar-la } seguent.addActionListener { // instruccions per a situar-se en la ruta seg\u00fcent, i visualitzar-la } ultim.addActionListener { // instruccions per a situar-se en l'\u00faltim ruta, i visualitzar-la } tancar.addActionListener { // instruccions per a tancar la BD i el programa } inicialitzar() VisRuta() } fun plenarTaula(ll_punts: MutableList<PuntGeo>) { var ll = Array(ll_punts.size) { arrayOfNulls<String>(3) } for (i in 0 until ll_punts.size) { ll[i][0] = ll_punts.get(i).nom ll[i][1] = ll_punts.get(i).coord.latitud.toString() ll[i][2] = ll_punts.get(i).coord.longitud.toString() } val caps = arrayOf(\"Nom punt\", \"Latitud\", \"Longitud\") punts.setModel(javax.swing.table.DefaultTableModel(ll, caps)) } fun inicialitzar() { // instruccions per a inicialitzar llista i numActual } fun VisRuta() { // instruccions per a visualitzar la ruta actual (l'\u00edndex el tenim en numActual ActivarBotons() } fun ActivarBotons() { // instruccions per a activar o desactivar els botons de moviment ( setEnabled(Boolean) ) } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraComplet().isVisible = true } }","title":"Exercici 6.2"},{"location":"exercicis/#exercici-63-voluntari","text":"Modificar la classe anterior per a incorporar tamb\u00e9 la dist\u00e0ncia total de la ruta . Per a poder calcular-la ens ajudarem de la seg\u00fcent funci\u00f3 que calcula la dist\u00e0ncia en quil\u00f2metres entre dos punts, donant les coordenades (latitud i longitud) dels dos punts: Dist(lat1,long1,lat2,long2) . Observeu que per a calcular la dist\u00e0ncia de forma correcta hem de tenir en compte tots els punts (si nom\u00e9s tenim en compte el primer punt i l'\u00faltim, la dist\u00e0ncia d'una ruta circular seria 0). Podeu incorporar-la a la classe on esteu fent l'exercici ( Ex2_VisRutes_DB4O.kt ). fun Dist(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double { val R = 6378.137 // Radi de la Tierra en km val dLat = rad(lat2 - lat1) val dLong = rad(lon2 - lon1) val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(rad(lat1)) * Math.cos(rad(lat2)) * Math.sin(dLong / 2) * Math.sin(dLong / 2) val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) val d = R * c return Math.round(d*100.0)/100.0 } fun rad(x: Double): Double { return x * Math.PI / 180 } Aquest seria un exemple: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici 6.3 (voluntari)"}]}